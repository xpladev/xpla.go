package staking

import (
	"encoding/hex"
	"fmt"
	"net"

	"github.com/xpladev/xpla.go/types"
	"github.com/xpladev/xpla.go/types/errors"
	"github.com/xpladev/xpla.go/util"

	cryptocodec "github.com/cosmos/cosmos-sdk/crypto/codec"
	cryptotypes "github.com/cosmos/cosmos-sdk/crypto/types"
	"github.com/cosmos/cosmos-sdk/server"
	sdk "github.com/cosmos/cosmos-sdk/types"
	"github.com/cosmos/cosmos-sdk/x/genutil"
	stakingtypes "github.com/cosmos/cosmos-sdk/x/staking/types"
	"github.com/tendermint/tendermint/crypto"
	tmjson "github.com/tendermint/tendermint/libs/json"
	tmtypes "github.com/tendermint/tendermint/types"
)

// Parsing - create validator
func parseCreateValidatorArgs(
	createValidatorMsg types.CreateValidatorMsg,
	from sdk.AccAddress,
	output string,
) (sdk.Msg, error) {

	var nodeId string
	var valPubKey cryptotypes.PubKey
	var err error

	privKeyValAddr := sdk.ValAddress(from)

	addrStr := createValidatorMsg.ValidatorAddress
	addr, err := sdk.ValAddressFromBech32(addrStr)
	if err != nil {
		return nil, util.LogErr(errors.ErrParse, err)
	}

	if privKeyValAddr.String() != addr.String() {
		return nil, util.LogErr(errors.ErrAccountNotMatch, "CreateValidatorMsg.ValidatorAddress and validator address generated by using private key are not same")
	}

	if createValidatorMsg.NodeKey != "" && createValidatorMsg.PrivValidatorKey != "" {
		nodeId, valPubKey, err = initializedNodeValidatorString(createValidatorMsg.NodeKey, createValidatorMsg.PrivValidatorKey)
		if err != nil {
			return nil, err
		}
	} else {
		serverCtx := server.NewDefaultContext()
		config := serverCtx.Config
		config.SetRoot(createValidatorMsg.HomeDir)

		nodeId, valPubKey, err = genutil.InitializeNodeValidatorFiles(serverCtx.Config)
		if err != nil {
			return nil, util.LogErr(errors.ErrParse, err)
		}
	}

	ip, err := getIP(createValidatorMsg.ServerIp)
	if err != nil {
		return nil, err
	}

	types.Memo = fmt.Sprintf("%s@%s:26656", nodeId, ip)

	website := createValidatorMsg.Website
	securityContact := createValidatorMsg.SecurityContact
	identity := createValidatorMsg.Identity
	details := createValidatorMsg.Details
	moniker := createValidatorMsg.Moniker

	var amount string
	if createValidatorMsg.Amount == "" {
		amount = types.DefaultAmount
	} else {
		amount = createValidatorMsg.Amount
	}

	var commissionRate string
	if createValidatorMsg.CommissionRate == "" {
		commissionRate = types.DefaultCommissionRate
	} else {
		commissionRate = createValidatorMsg.CommissionRate
	}

	var commissionMaxRate string
	if createValidatorMsg.CommissionMaxRate == "" {
		commissionMaxRate = types.DefaultCommissionMaxRate
	} else {
		commissionMaxRate = createValidatorMsg.CommissionMaxRate
	}

	var commissionMaxChangeRate string
	if createValidatorMsg.CommissionMaxChangeRate == "" {
		commissionMaxChangeRate = types.DefaultCommissionMaxChangeRate
	} else {
		commissionMaxChangeRate = createValidatorMsg.CommissionMaxChangeRate
	}

	var minSelfDelegation string
	if createValidatorMsg.MinSelfDelegation == "" {
		minSelfDelegation = types.DefaultMinSelfDelegation
	} else {
		minSelfDelegation = createValidatorMsg.MinSelfDelegation
	}

	description := stakingtypes.NewDescription(
		moniker, identity, website, securityContact, details)

	amountCoins, err := sdk.ParseCoinNormalized(amount)
	if err != nil {
		return nil, util.LogErr(errors.ErrParse, err)
	}

	buildCRates, err := buildCommissionRates(commissionRate, commissionMaxRate, commissionMaxChangeRate)
	if err != nil {
		return nil, err
	}

	intMinSelfDelegation, ok := sdk.NewIntFromString(minSelfDelegation)
	if !ok {
		return nil, util.LogErr(errors.ErrInvalidRequest, "wrong minSelfDelegation")
	}

	msg, err := stakingtypes.NewMsgCreateValidator(addr, valPubKey, amountCoins, description, buildCRates, intMinSelfDelegation)
	if err != nil {
		return nil, util.LogErr(errors.ErrParse, err)
	}
	return msg, nil
}

// Parsing - edit validator
func parseEditValidatorArgs(editValidatorMsg types.EditValidatorMsg, addr sdk.AccAddress) (stakingtypes.MsgEditValidator, error) {
	moniker := editValidatorMsg.Moniker
	identity := editValidatorMsg.Identity
	website := editValidatorMsg.Website
	security := editValidatorMsg.SecurityContact
	details := editValidatorMsg.Details
	description := stakingtypes.NewDescription(moniker, identity, website, security, details)

	var newRate *sdk.Dec

	commisionRate := editValidatorMsg.CommissionRate
	if commisionRate != "" {
		rate, err := sdk.NewDecFromStr(commisionRate)
		if err != nil {
			return stakingtypes.MsgEditValidator{}, util.LogErr(errors.ErrParse, err)
		}
		newRate = &rate
	}

	var newMinSelfDelegation *sdk.Int

	minSelfDelegation := editValidatorMsg.MinSelfDelegation
	if minSelfDelegation != "" {
		msb, ok := sdk.NewIntFromString(minSelfDelegation)
		if !ok {
			return stakingtypes.MsgEditValidator{}, util.LogErr(errors.ErrInvalidRequest, "minimum self delegation must be a positive integer")
		}
		newMinSelfDelegation = &msb
	}

	msg := stakingtypes.NewMsgEditValidator(sdk.ValAddress(addr), description, newRate, newMinSelfDelegation)

	return *msg, nil
}

// Parsing - delegate
func parseDelegateArgs(delegateMsg types.DelegateMsg, delAddr sdk.AccAddress) (stakingtypes.MsgDelegate, error) {
	amount, err := sdk.ParseCoinNormalized(util.DenomAdd(delegateMsg.Amount))
	if err != nil {
		return stakingtypes.MsgDelegate{}, util.LogErr(errors.ErrParse, err)
	}

	valAddr, err := sdk.ValAddressFromBech32(delegateMsg.ValAddr)
	if err != nil {
		return stakingtypes.MsgDelegate{}, util.LogErr(errors.ErrParse, err)
	}

	msg := stakingtypes.NewMsgDelegate(delAddr, valAddr, amount)

	return *msg, nil
}

// Parsing - unbond
func parseUnbondArgs(unbondMsg types.UnbondMsg, delAddr sdk.AccAddress) (stakingtypes.MsgUndelegate, error) {
	amount, err := sdk.ParseCoinNormalized(util.DenomAdd(unbondMsg.Amount))
	if err != nil {
		return stakingtypes.MsgUndelegate{}, util.LogErr(errors.ErrParse, err)
	}

	valAddr, err := sdk.ValAddressFromBech32(unbondMsg.ValAddr)
	if err != nil {
		return stakingtypes.MsgUndelegate{}, util.LogErr(errors.ErrParse, err)
	}

	msg := stakingtypes.NewMsgUndelegate(delAddr, valAddr, amount)

	return *msg, nil
}

// Parsing - redelegate
func parseRedelegateArgs(redelegateMsg types.RedelegateMsg, delAddr sdk.AccAddress) (stakingtypes.MsgBeginRedelegate, error) {
	amount, err := sdk.ParseCoinNormalized(util.DenomAdd(redelegateMsg.Amount))
	if err != nil {
		return stakingtypes.MsgBeginRedelegate{}, util.LogErr(errors.ErrParse, err)
	}

	valSrcAddr, err := sdk.ValAddressFromBech32(redelegateMsg.ValSrcAddr)
	if err != nil {
		return stakingtypes.MsgBeginRedelegate{}, util.LogErr(errors.ErrParse, err)
	}
	valDstAddr, err := sdk.ValAddressFromBech32(redelegateMsg.ValDstAddr)
	if err != nil {
		return stakingtypes.MsgBeginRedelegate{}, util.LogErr(errors.ErrParse, err)
	}

	msg := stakingtypes.NewMsgBeginRedelegate(delAddr, valSrcAddr, valDstAddr, amount)
	return *msg, nil
}

// Parsing - historical
func parseHistoricalInfoArgs(historicalMsg types.HistoricalInfoMsg) (stakingtypes.QueryHistoricalInfoRequest, error) {
	height := historicalMsg.Height
	heightInt, err := util.FromStringToInt64(height)
	if err != nil {
		return stakingtypes.QueryHistoricalInfoRequest{}, util.LogErr(errors.ErrParse, err)
	}
	if heightInt < 0 {
		return stakingtypes.QueryHistoricalInfoRequest{}, util.LogErr(errors.ErrInvalidRequest, "height argument provided must be a non-negative-integer")
	}

	return stakingtypes.QueryHistoricalInfoRequest{Height: heightInt}, nil
}

// Build commission rate
func buildCommissionRates(rateStr, maxRateStr, maxChangeRateStr string) (commission stakingtypes.CommissionRates, err error) {
	if rateStr == "" || maxRateStr == "" || maxChangeRateStr == "" {
		return commission, util.LogErr(errors.ErrInsufficientParams, "must specify all validator commission parameters")
	}
	rate, err := sdk.NewDecFromStr(rateStr)
	if err != nil {
		return commission, util.LogErr(errors.ErrParse, err)
	}
	maxRate, err := sdk.NewDecFromStr(maxRateStr)
	if err != nil {
		return commission, util.LogErr(errors.ErrParse, err)
	}
	maxChangeRate, err := sdk.NewDecFromStr(maxChangeRateStr)
	if err != nil {
		return commission, util.LogErr(errors.ErrParse, err)
	}
	commission = stakingtypes.NewCommissionRates(rate, maxRate, maxChangeRate)

	return commission, nil
}

type FilePVKey struct {
	Address tmtypes.Address `json:"address"`
	PubKey  crypto.PubKey   `json:"pub_key"`
	PrivKey crypto.PrivKey  `json:"priv_key"`
}

type NodeKey struct {
	PrivKey crypto.PrivKey `json:"priv_key"` // our priv key
}

func initializedNodeValidatorString(nodeKey string, privValKey string) (string, cryptotypes.PubKey, error) {

	nodeKeyType := new(NodeKey)
	err := tmjson.Unmarshal([]byte(nodeKey), nodeKeyType)
	if err != nil {
		return "", nil, util.LogErr(errors.ErrFailedToUnmarshal, err)
	}

	nodeID := hex.EncodeToString(nodeKeyType.PrivKey.PubKey().Address())

	pvKey := FilePVKey{}
	err = tmjson.Unmarshal([]byte(privValKey), &pvKey)
	if err != nil {
		return "", nil, util.LogErr(errors.ErrFailedToUnmarshal, "err reading privValidator key, ", err)
	}

	// overwrite pubkey and address for convenience
	pvKey.PubKey = pvKey.PrivKey.PubKey()
	pvKey.Address = pvKey.PubKey.Address()

	valPubKey, err := cryptocodec.FromTmPubKeyInterface(pvKey.PubKey)
	if err != nil {
		return "", nil, util.LogErr(errors.ErrParse, err)
	}

	return nodeID, valPubKey, nil

}

func getIP(startingIPAddr string) (ip string, err error) {
	if len(startingIPAddr) == 0 {
		ip, err = server.ExternalIP()
		if err != nil {
			return "", err
		}
		return ip, nil
	}
	return calculateIP(startingIPAddr)
}

func calculateIP(ip string) (string, error) {
	ipv4 := net.ParseIP(ip).To4()
	if ipv4 == nil {
		return "", fmt.Errorf("%v: non ipv4 address", ip)
	}

	return ipv4.String(), nil
}
